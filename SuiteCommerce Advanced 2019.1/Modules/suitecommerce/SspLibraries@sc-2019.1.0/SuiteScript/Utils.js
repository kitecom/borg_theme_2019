/*
	Â© 2019 NetSuite Inc.
	User may not copy, modify, distribute, or re-bundle or otherwise make available this code;
	provided, however, if you are an authorized user with a NetSuite account or log-in, you
	may use this code subject to the terms that govern your access and use.
*/

// @module ssp.libraries
define('Utils'
	, [
		'SC.Models.Init'
		, 'underscore'
	]
	, function (
		ModelsInit
		, _
	)
	{
		'use strict';

		function _getColumnLabel(column)
		{
			var formula = column.getFormula();
			if (formula)
			{
				// if the column is a formula prefer the label
				// because the name is autogenerated: 'formulanumeric' or similar
				return column.getLabel() || column.getName();
			}
			else
			{
				return column.getName();
			}
		}

		// @class Utils contain global utility methods from high level API for searching records, format currencies, record type meta information, etc
		var Utils = {

			//@function deepCopy Deep Copy of the object taking care of Backbone models
			//@param {Object} obj Object to be copy
			//@return {Object}
			deepCopy: function deepCopy(obj)
			{

				if (_.isFunction(obj) || this.isInstanceOfnlobjRecord(obj))
				{
					return null;
				}

				var copy = {}
					, self = this;

				if (_.isArray(obj))
				{
					copy = [];
					_.each(obj, function (value)
					{
						!_.isFunction(value) && copy.push(self.deepCopy(value));
					});
				}
				else if (_.isObject(obj))
				{
					for (var i = 0; i < Object.keys(obj).length; i++)
					{
						var attr = Object.keys(obj)[i];
						var value = obj[attr];
						if (!_.isFunction(value) && _.isString(attr) && attr.indexOf('_') !== 0)
						{
							copy[attr] = self.deepCopy(value);
						}
					}
				}
				else
				{
					copy = obj;
				}

				return copy;
			}

			, isInstanceOfnlobjRecord: function (record)
			{
				return record && !_.isString(record) && !_.isNumber(record) && !_.isBoolean(record) &&
					_.isFunction(record.getRecordType) && _.isFunction(record.getId);
			}

			// @method isDateType
			// @param {string}
			// @returns {Boolean}
			, isDateType: function (field)
			{
				//Return true if the type of this field is expected to be date.
				return field === 'trandate' || field === 'createddate' || field === 'datecreated';
			}

			, transformDateFormat: function (format)
			{
				// Format conversion
				// Suitescript value - moment value
				//
				// Date format
				// 	"fmMM/DDfm/YYYY" ~ MM/DD/YYYY
				// 	"fmDD/MMfm/YYYY" ~ DD/MM/YYYY
				// 	"fmDD-Monfm-YYYY" ~ DD-MMM-YYYY
				// 	"fmDD.MMfm.YYYY" ~ DD.MM.YYYY
				// 	"fmDD-MONTHfm-YYYY" ~ DD-MMMM-YYYY
				// 	"fmDD MONTHfm", YYYY ~ DD MMMM, YYYY
				// 	"YYYY-fmMM-DDfm" ~ YYYY-MM-DD
				// 	"DD/MM/YYYY" ~ DD/MM/YYYY
				// 	"DD-Mon-YYYY" ~ DD-MMM-YYYY
				// 	"DD-MONTH-YYYY" ~ DD-MMMM-YYYY
				//
				// LongDate Format
				// 	"fmDD Monthfm YYYY" ~ DD MMMM YYYY
				// 	"fmMonth DDfm, YYYY" ~ MMMM DD, YYYY
				//	"YYYY fmMonth DDfm" ~ YYYY MMMM DD
				// 	"Month DD, YYYY" ~ MMMM DD, YYYY
				// 	"DD Month YYYY" ~ DD MMMM, YYYY
				// 	"YYYY Month DD" ~ YYYY MMMM DD

				return format.toUpperCase()
					.replace('FMMM', 'MM')
					.replace('MMFM', 'MM')
					.replace('FMDD', 'DD')
					.replace('DDFM', 'DD')
					.replace('MONTHFM', 'MMMM')
					.replace('FMMONTH', 'MMMM')
					.replace('MONTH', 'MMMM')
					.replace('MONFM', 'MMM')
					.replace('FMMON', 'MMM')
					.replace('MON', 'MMM');
			}

			, transformTimeFormat: function (format)
			{
				// Format conversion
				// Suitescript value - moment value
				//"fmHH:fmMI am" ~ hh:mm A
				//"fmHH24:fmMI" ~ HH:mm
				//"fmHH-fmMI am" ~ hh-mm A
				//"fmHH24-fmMI" ~ HH-mm

				return format.toUpperCase()
					.replace('FMHH', 'hh')
					.replace('FMMI', 'mm')
					.replace('hh24', 'HH')
					.replace('AM', 'A');
			}

			// @method mapSearchResult
			// @param {Array<nlobjSearchColumn>}
			// @param {nlobjSearchColumn} apiElement columns
			// @returns {Object}
			, mapSearchResult: function mapSearchResult(columns, apiElement)
			{
				var element = {};

				columns.forEach(function (column)
				{
					var col = column.searchColumn
						, name = col.getName()
						, text = apiElement.getText(name, col.getJoin(), col.getSummary())
						, value = apiElement.getValue(name, col.getJoin(), col.getSummary())
						, has_function = col.getFunction()
						, fieldName = column.fieldName
						, is_datetype = Utils.isDateType(fieldName);

					//If this field is trandate, datecreated or createddate and has no functions associated, we apply the nlapiStringToDate
					//	function to convert this field in a date (ISO 8601 - https://www.w3.org/TR/NOTE-datetime).
					element[fieldName] = is_datetype && !has_function ? nlapiStringToDate(value) : value;

					if (text)
					{
						element[fieldName + '_text'] = text;
					}
				});
				return element;
			}

			// @method mapSearchResults Extracts search results to a JSON-friendly format.
			// @param {Array<nlobjSearchColumn>} searchColumns
			// @param {Array<nlobjSearchResult>} searchResults
			// @return {Array<nlobjSearchResult>} mapped results
			// @private
			, mapSearchResults: function mapSearchResults(searchColumns, searchResults)
			{
				if (!searchColumns || !searchResults)
				{
					return [];
				}

				var nameToCol = {} // mapping columnName -> columns with that name
					, columns = []; // array of { searchColumn: (nlobjSearchColumn), fieldName: (name in result) }

				// detect columns with the same name
				_.each(searchColumns, function (col)
				{
					var name = _getColumnLabel(col);
					columns.push(
					{
						searchColumn: col
					});
					nameToCol[name] = (nameToCol[name] || 0) + 1;
				});
				// sets fieldNames for each column
				_.each(columns, function (column)
				{
					var searchColumn = column.searchColumn
						, isANameClash = nameToCol[_getColumnLabel(searchColumn)] > 1
						, coulumnJoim = searchColumn.getJoin();

					column.fieldName = _getColumnLabel(searchColumn);
					if (isANameClash && coulumnJoim)
					{
						column.fieldName += '_' + coulumnJoim;
					}
				});

				return searchResults.map(function (apiElement)
				{
					return Utils.mapSearchResult(columns, apiElement);
				});
			}

			// @method mapLoadResult
			// @param {Array<nlobjSearchColumn>} columns
			// @param {nlobjRecord} record
			// @return {Object}
			, mapLoadResult: function mapLoadResult(columns, record)
			{
				var record_info = {};
				columns.forEach(function (name)
				{
					var value = record.getFieldValue(name);
					if (name === 'image' && !!value)
					{
						var imageRecord = nlapiLoadFile(value);
						if (!!imageRecord)
						{
							record_info[name] = imageRecord.getURL();
						}
						else
						{
							record_info[name] = '';
						}
					}
					else
					{
						record_info[name] = value;
					}
				});
				return record_info;
			}

			, loadAndExecuteSearch: function loadAndExecuteSearch(searchName, filters)
			{
				var savedSearch = nlapiLoadSearch(null, searchName);
				var filtersSS = savedSearch.getFilters();
				savedSearch.setFilterExpression(filters);
				savedSearch.addFilters(filtersSS);
				var runSearch = savedSearch.runSearch();
				var searchResults = runSearch.getResults(0, 1000);
				return Utils.mapSearchResults(savedSearch.getColumns(), searchResults);
			}

			// @method loadAndMapSearch
			// @param {String}searchName
			// @param {Array<nlobjSearchFilter>} filters
			// @return {Array<nlobjSearchResult>} mapped results
			, loadAndMapSearch: function loadAndMapSearch(searchName, filters)
			{
				var savedSearch;
				filters = filters || [];

				try
				{
					savedSearch = nlapiLoadSearch(null, searchName);
				}
				catch (err)
				{
					console.log('Unable to load search ' + searchName, err);
					return [];
				}
				var searchResults = nlapiSearchRecord(null, searchName, filters);
				return Utils.mapSearchResults(savedSearch.getColumns(), searchResults);
			}


			/**
			 * @method mapOptions @param {String} record_options
			 */
			, mapOptions: function mapOptions(record_options)
			{
				var options_rows = record_options.split('\u0004');
				var options_items = options_rows.map(function (row)
				{
					return row.split('\u0003');
				});
				var options = {};
				options_items.forEach(function (item)
				{
					options[item[0]] = {
						name: item[0]
						, desc: item[2]
						, value: item[3]
					};
				});
				return options;
			}

			/**
			 * @method makeid @param {Number} maxLength
			 */
			, makeid: function makeid(maxLength)
			{
				return Math.random().toString(36).substring(2, (maxLength + 2) || 5);
			}

			/**
			 * @method getMolecule
			 * @param {nlobjRequest} request
			 * @returns {String}
			 *		''		system
			 *		'f'		system.f
			 *		'p'		system.p
			 *		'na1.f'	system.na1.f
			 */
			, getMolecule: function getMolecule(request)
			{
				var regex = /https:\/\/system(.*)\.netsuite\.com/;
				var molecule = request.getURL().match(regex);
				return molecule && molecule[1] || '';
			}

			// @method formatReceiptCurrency @param {String|Number} value
			, formatReceiptCurrency: function formatReceiptCurrency(value)
			{
				var parsedValue = parseFloat(value);
				if (parsedValue < 0)
				{
					if (value.substring)
					{
						return '($ ' + value.substring(1) + ')';
					}

					return '($ ' + value.toFixed(2).substring(1) + ')';
				}

				return '$ ' + parsedValue.toFixed(2);
			}


			// @method sanitizeString Remove any HTML code form the string
			// @param {String} text String with possible HTML code in it
			// @return {String} HTML-free string
			, sanitizeString: function (text)
			{
				return text ? text.replace(/<br>/g, '\n').replace(/</g, '&lt;').replace(/\>/g, '&gt;') : '';
			}

			// @method formatCurrency @param {String} value @param {String} symbol
			, formatCurrency: function (value, symbol)
			{
				var value_float 
				, 	beforeValue = true;

				if (!value || isNaN(value))
				{
					value_float = parseFloat(0); //return value;
				}else{
					value_float = parseFloat(value); //return value;
				}

				var negative = value_float < 0;
				value_float = Math.abs(value_float);
				value_float = parseInt((value_float + 0.005) * 100, 10) / 100;

				var value_string = value_float.toString()
				, groupseparator = ','
					, decimalseparator = '.'
					, negativeprefix = '('
					, negativesuffix = ')'
					, settings = SC && SC.ENVIRONMENT && SC.ENVIRONMENT.siteSettings ? SC.ENVIRONMENT.siteSettings :
					{};

				if (window.hasOwnProperty('groupseparator'))
				{
					groupseparator = window.groupseparator;
				}
				else if (settings.hasOwnProperty('groupseparator'))
				{
					groupseparator = settings.groupseparator;
				}

				if (window.hasOwnProperty('decimalseparator'))
				{
					decimalseparator = window.decimalseparator;
				}
				else if (settings.hasOwnProperty('decimalseparator'))
				{
					decimalseparator = settings.decimalseparator;
				}

				if (window.hasOwnProperty('negativeprefix'))
				{
					negativeprefix = window.negativeprefix;
				}
				else if (settings.hasOwnProperty('negativeprefix'))
				{
					negativeprefix = settings.negativeprefix;
				}

				if (window.hasOwnProperty('negativesuffix'))
				{
					negativesuffix = window.negativesuffix;
				}
				else if (settings.hasOwnProperty('negativesuffix'))
				{
					negativesuffix = settings.negativesuffix;
				}

				value_string = value_string.replace('.', decimalseparator);
				var decimal_position = value_string.indexOf(decimalseparator);

				// if the string doesn't contains a .
				if (!~decimal_position)
				{
					value_string += decimalseparator + '00';
					decimal_position = value_string.indexOf(decimalseparator);
				}
				// if it only contains one number after the .
				else if (value_string.indexOf(decimalseparator) === (value_string.length - 2))
				{
					value_string += '0';
				}

				var thousand_string = '';
				for (var i = value_string.length - 1; i >= 0; i--)
				{
					//If the distance to the left of the decimal separator is a multiple of 3 you need to add the group separator
					thousand_string = (i > 0 && i < decimal_position && (((decimal_position - i) % 3) === 0) ? groupseparator : '') + value_string[i] + thousand_string;
				}

				var currencies = ModelsInit.session.getSiteSettings(['currencies']).currencies;

				if (!symbol)
				{
					if (typeof ModelsInit.session !== 'undefined' && ModelsInit.session.getShopperCurrency)
					{
						try
						{
							symbol = ModelsInit.session.getShopperCurrency().symbol;
						}
						catch (e)
						{}
					}
					else if (settings.shopperCurrency)
					{
						symbol = settings.shopperCurrency.symbol;
					}
					else if (SC && SC.ENVIRONMENT && SC.ENVIRONMENT.currentCurrency)
					{
						symbol = SC.ENVIRONMENT.currentCurrency.symbol;
					}

					if (!symbol)
					{
						symbol = '$';
					}
				}

				var matchingcurrency;

				if(!isNaN(symbol)){
					matchingcurrency = _.findWhere(currencies, {
						internalid: symbol
					});
				}else{
					matchingcurrency = _.findWhere(currencies, {
						symbol: symbol
					});
				}

				if(matchingcurrency){
					beforeValue = (matchingcurrency.symbolplacement == 1);
					symbol = matchingcurrency.symbol;
				}
			
				var aux = negative ? (negativeprefix + thousand_string + negativesuffix) : thousand_string;
				value_string = beforeValue ? symbol + aux : aux + symbol;

				return value_string;
			}
			

			, isDepartmentMandatory: function (record)
			{
				if (record)
				{
					var field = record.getField('department');

					return field && field.mandatory;
				}
				else
				{
					var department_mandatory = this._getAccountingPreferenceField('DEPTMANDATORY');

					return department_mandatory === 'T';
				}

			}

			, isLocationMandatory: function ()
			{
				var location_mandatory = this._getAccountingPreferenceField('LOCMANDATORY');

				return location_mandatory === 'T';
			}

			, isClassMandatory: function ()
			{

				var class_mandatory = this._getAccountingPreferenceField('CLASSMANDATORY');

				return class_mandatory === 'T';
			}

			, isFulfillmentRequestEnabled: function ()
			{
				return this.isFeatureEnabled('FULFILLMENTREQUEST');
			}

			, isFeatureEnabled: function (feature)
			{
				return ModelsInit.context.getFeature(feature);
			}

			// @method isCheckoutDomain determines if we are in a secure checkout
			// domain or in a secure single domain environment
			// @return {Boolean} true if in checkout or in single domain
			, isCheckoutDomain: function isCheckoutDomain()
			{
				return ModelsInit.session.isCheckoutSupported();
			}

			// @method isShoppingDomain determines if we are in shopping domain (secure or non secure)
			//  or in a secure single domain environment
			// @return {Boolean} true if in shopping or single domain
			, isShoppingDomain: function isShoppingDomain()
			{
				return ModelsInit.session.isShoppingSupported();
			}

			// @method isSingleDomain determines if we are in a single domain environment
			// @return {Boolean} true if single domain
			, isSingleDomain: function isSingleDomain()
			{
				return this.isShoppingDomain() && this.isCheckoutDomain();
			}

			// @method isInShopping determines if we are in shopping ssp
			// @return {Boolean} true if in shopping domain, false if in checkout or myaccount
			, isInShopping: function isInShopping(request)
			{
				return this.isShoppingDomain() && (request.getHeader('X-SC-Touchpoint') === 'shopping' || request.getParameter('X-SC-Touchpoint') === 'shopping');
			}

			, isHttpsSupported: function isHttpsSupported()
			{
				return ~ModelsInit.session.getSiteSettings(['touchpoints']).touchpoints.home.indexOf('https');
			}

			// @method isInCheckout determines if we are in checkout ssp or my account ssp
			// @return {Boolean} true if in checkout domain
			, isInCheckout: function isInCheckout(request)
			{
				var self = this;

				if (!self.isSingleDomain())
				{
					return self.isCheckoutDomain();
				}
				else
				{
					var paypal_complete = ModelsInit.context.getSessionObject('paypal_complete') === 'T'
						, is_in_checkout = request.getHeader('X-SC-Touchpoint') === 'checkout' ||
						request.getHeader('X-SC-Touchpoint') === 'myaccount' ||
						request.getParameter('X-SC-Touchpoint') === 'checkout' ||
						request.getParameter('X-SC-Touchpoint') === 'myaccount';

					return self.isCheckoutDomain() && (is_in_checkout || paypal_complete);
				}
			}

			// Not used for now because there is only Full permissions on accountingpreferences
			, _isAccountingPreferenceEnabled: function (preference)
			{
				var accounting_preferences;

				try
				{
					accounting_preferences = nlapiLoadConfiguration('accountingpreferences');
				}
				catch (err)
				{
					// The operation requires "Accounting Preferences" permission.
					// Validation is ommited if the user doesn't have it.
					return;
				}

				return accounting_preferences.getFieldValue(preference) === 'T';
			}

			, _getAccountingPreferenceField: function (preference)
			{
				try
				{
					var context = ModelsInit.context
						, accounting_preferences = context.getPreference(preference);

					return accounting_preferences;
				}
				catch (err)
				{
					return;
				}
			}

			// @method toCurrency @param {String} amount @return {Number}
			, toCurrency: function (amount)
			{
				var r = parseFloat(amount);

				return isNaN(r) ? 0 : r;
			}

			// @method recordTypeExists returns true if and only if the given record type name is present in the current account - useful for checking if a bundle is installed or not in this account.
			// @param {String} record_type_name @return{Boolean}
			, recordTypeExists: function (record_type_name)
			{
				try
				{
					nlapiCreateSearch(record_type_name, null, [], []);
				}
				catch (error)
				{
					return false;
				}
				return true;
			}

			// @method recordTypeHasField returns true if and only if the given field_name exists on the given record_type_name.
			// @param {String} record_type_name @param {String} field_name @return {Boolean}
			, recordTypeHasField: function (record_type_name, field_name)
			{
				try
				{
					nlapiLookupField(record_type_name, 1, field_name);
					return true;
				}
				catch (error)
				{
					return false;
				}
			}


			, getTransactionType: function (internalid)
			{
				try
				{
					return nlapiLookupField('transaction', internalid, 'recordtype');
				}
				catch (error)
				{
					return '';
				}

			}

			//@method getItemOptionsObject Parse an item string options into an object
			//@param {String} options_string String containg all item options
			//@return {Utils.ItemOptionsObject} Returns an object with the properties: id, name, value, displayvalue and mandatory
			, getItemOptionsObject: function (options_string)
			{
				var options_object = [];

				if (options_string && options_string !== '- None -')
				{
					var split_char_3 = String.fromCharCode(3)
						, split_char_4 = String.fromCharCode(4);

					_.each(options_string.split(split_char_4), function (option_line)
					{
						option_line = option_line.split(split_char_3);
						//@class Utils.ItemOptionsObject
						options_object.push(
						{
							//@property {String} id
							id: option_line[0] //OPTION INTERNAL ID (lowercase)
								//@property {String} name
							, name: option_line[2] //OPTION LABEL
								//@property {String} value
							, value: option_line[3] // TO REMOVE
								//@property {String} displayValue
							, displayvalue: option_line[4] // TO REMOVE
								//@property {String} mandatory
							, mandatory: option_line[1] // Boolean

							//,	value: {label: option_line[4], internalid: option_line[3]}
						});
						//@class Utils
					});
				}

				return options_object;
			}

			// @method setPaymentMethodToResult @param {nlobjRecord} record @param {Object} result
			, setPaymentMethodToResult: function (record, result)
			{
				var paymentmethod = {
						type: record.getFieldValue('paymethtype')
						, primary: true
						, name: record.getFieldText('paymentmethod')
					}
					, ccnumber = record.getFieldValue('ccnumber');

				if (ccnumber)
				{
					paymentmethod.type = 'creditcard';

					paymentmethod.creditcard = {
						ccnumber: ccnumber
						, ccexpiredate: record.getFieldValue('ccexpiredate')
						, ccname: record.getFieldValue('ccname')
						, internalid: record.getFieldValue('creditcard')
						, paymentmethod:
						{
							ispaypal: 'F'
							, name: record.getFieldText('paymentmethod')
							, creditcard: 'T'
							, internalid: record.getFieldValue('paymentmethod')
						}
					};
				}

				if (record.getFieldValue('ccstreet'))
				{
					paymentmethod.ccstreet = record.getFieldValue('ccstreet');
				}

				if (record.getFieldValue('cczipcode'))
				{
					paymentmethod.cczipcode = record.getFieldValue('cczipcode');
				}

				if (record.getFieldValue('terms'))
				{
					paymentmethod.type = 'invoice';

					paymentmethod.purchasenumber = record.getFieldValue('otherrefnum');

					paymentmethod.paymentterms = {
						internalid: record.getFieldValue('terms')
						, name: record.getFieldText('terms')
					};
				}

				result.paymentmethods = [paymentmethod];
			}

			//@method trim Remove starting and ending spaced from the passed in string
			//@param {String} str
			//@return {String}
			, trim: function trim(str)
			{
				return str.replace(/^\s+|\s+$/gm, '');
			}

			//@method stringEndsWith Indicate if the first string ends with the second one
			//@para {String} str Original string used to check it end
			//@param {String} suffix
			//@return {Boolean}
			, stringEndsWith: function (str, suffix)
			{
				return str.indexOf(suffix, str.length - suffix.length) !== -1;
			}

			, getPathFromObject: function (object, path, default_value)
				{
					if (!path)
					{
						return object;
					}
					else if (object)
					{
						var tokens = path.split('.')
							, prev = object
							, n = 0;

						while (!_.isUndefined(prev) && n < tokens.length)
						{
							prev = prev[tokens[n++]];
						}

						if (!_.isUndefined(prev))
						{
							return prev;
						}
					}

					return default_value;
				}
				// @method setPathFromObject @param {Object} object @param {String} path a path with values separated by dots @param {Any} value the value to set
			, setPathFromObject: function (object, path, value)
			{
				if (!path)
				{
					return;
				}
				else if (!object)
				{
					return;
				}

				var tokens = path.split('.')
					, prev = object;

				for (var token_idx = 0; token_idx < tokens.length - 1; ++token_idx)
				{
					var current_token = tokens[token_idx];

					if (_.isUndefined(prev[current_token]))
					{
						prev[current_token] = {};
					}
					prev = prev[current_token];
				}

				prev[_.last(tokens)] = value;
			}

			// @method getTodayDate @return {Date}
			, getTodayDate: function ()
			{
				this.today = this.today || new Date().getTime();
				return new Date(this.today);
			}

			, removeSecondsFromDateTimeField: function removeSecondsFromDateTimeField(value)
			{
				if (value)
				{
					var aux = value.split(':')
						, result = aux[0] + ':' + aux[1];

					if (aux.length === 3)
					{
						var ampm = aux[2].split(' ')[1];
						result += ' ' + ampm;
					}

					return nlapiStringToDate(result);
				}
				else
				{
					return null;
				}
			}

			//@method getCurrencyById Get currency by internalid
			//@return {Currency}
		,	getCurrencyById: function (currency_id)
			{
				var selected_currency
				,	siteSettings_currencies = ModelsInit.session.getSiteSettings(['currencies']);

				if (currency_id && siteSettings_currencies) {
					selected_currency = _.find(siteSettings_currencies.currencies, function (currency)
					{
						return currency.internalid === currency_id;
					});				
				}
				
				return selected_currency;
			}				
		};

		return Utils;
	});